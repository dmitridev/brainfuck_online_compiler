{"version":3,"file":"vue-handsontable.min.js","sources":["../src/helpers.ts","../src/lib/lru/lru.js","../node_modules/vue-runtime-helpers/dist/normalize-component.js","../node_modules/vue-class-component/dist/vue-class-component.esm.js"],"sourcesContent":["import Vue, { VNode } from 'vue';\nimport Handsontable from 'handsontable';\nimport { HotTableProps, VueProps, EditorComponent } from './types';\n\nconst unassignedPropSymbol = Symbol('unassigned');\nlet bulkComponentContainer = null;\n\n/**\n * Rewrite the settings object passed to the watchers to be a clean array/object prepared to use within Handsontable config.\n *\n * @param {*} observerSettings Watcher object containing the changed data.\n * @returns {Object|Array}\n */\nexport function rewriteSettings(observerSettings): any[] | object {\n  const settingsType = Object.prototype.toString.call(observerSettings);\n  let settings: any[] | object | null = null;\n  let type: { array?: boolean, object?: boolean } = {};\n\n  if (settingsType === '[object Array]') {\n    settings = [];\n    type.array = true;\n\n  } else if (settingsType === '[object Object]') {\n    settings = {};\n    type.object = true;\n  }\n\n  if (type.array || type.object) {\n    for (const p in observerSettings) {\n      if (observerSettings.hasOwnProperty(p)) {\n        settings[p] = observerSettings[p];\n      }\n    }\n\n  } else {\n    settings = observerSettings;\n  }\n\n  return settings;\n}\n\n/**\n * Private method to ensure the table is not calling `updateSettings` after editing cells.\n * @private\n */\nexport function preventInternalEditWatch(component) {\n  component.hotInstance.addHook('beforeChange', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateCol', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveCol', () => {\n    component.__internalEdit = true;\n  });\n}\n\n/**\n * Generate an object containing all the available Handsontable properties and plugin hooks.\n *\n * @param {String} source Source for the factory (either 'HotTable' or 'HotColumn').\n * @returns {Object}\n */\nexport function propFactory(source): VueProps<HotTableProps> {\n  const registeredHooks: string[] = Handsontable.hooks.getRegistered();\n\n  const propSchema: VueProps<HotTableProps> = new Handsontable.DefaultSettings();\n\n  for (let prop in propSchema) {\n    propSchema[prop] = {\n      default: unassignedPropSymbol\n    };\n  }\n\n  for (let i = 0; i < registeredHooks.length; i++) {\n    propSchema[registeredHooks[i]] = {\n      default: unassignedPropSymbol\n    };\n  }\n\n  propSchema.settings = {\n    default: unassignedPropSymbol\n  };\n\n  if (source === 'HotTable') {\n    propSchema.id = {\n      type: String,\n      default: 'hot-' + Math.random().toString(36).substring(5)\n    };\n\n    propSchema.wrapperRendererCacheSize = {\n      type: Number,\n      default: 3000\n    };\n  }\n\n  return propSchema;\n}\n\n/**\n * Filter out all of the unassigned props, and return only the one passed to the component.\n *\n * @param {Object} props Object containing all the possible props.\n * @returns {Object} Object containing only used props.\n */\nexport function filterPassedProps(props) {\n  const filteredProps: VueProps<HotTableProps> = {};\n  const columnSettingsProp = props['settings'];\n\n  if (columnSettingsProp !== unassignedPropSymbol) {\n    for (let propName in columnSettingsProp) {\n      if (columnSettingsProp.hasOwnProperty(propName) && columnSettingsProp[propName] !== unassignedPropSymbol) {\n        filteredProps[propName] = columnSettingsProp[propName];\n      }\n    }\n  }\n\n  for (let propName in props) {\n    if (props.hasOwnProperty(propName) && propName !== 'settings' && props[propName] !== unassignedPropSymbol) {\n      filteredProps[propName] = props[propName];\n    }\n  }\n\n  return filteredProps;\n}\n\n/**\n * Prepare the settings object to be used as the settings for Handsontable, based on the props provided to the component.\n *\n * @param {Object} props The props passed to the component.\n * @returns {Object} An object containing the properties, ready to be used within Handsontable.\n */\nexport function prepareSettings(props: HotTableProps): Handsontable.GridSettings {\n  const assignedProps: VueProps<HotTableProps> = filterPassedProps(props);\n  const hotSettingsInProps: {} = props.settings ? props.settings : assignedProps;\n  const additionalHotSettingsInProps: Handsontable.GridSettings = props.settings ? assignedProps : null;\n  const newSettings = {};\n\n  for (const key in hotSettingsInProps) {\n    if (hotSettingsInProps.hasOwnProperty(key) && hotSettingsInProps[key] !== void 0) {\n      newSettings[key] = hotSettingsInProps[key];\n    }\n  }\n\n  for (const key in additionalHotSettingsInProps) {\n    if (key !== 'id' && key !== 'settings' && key !== 'wrapperRendererCacheSize' && additionalHotSettingsInProps.hasOwnProperty(key) && additionalHotSettingsInProps[key] !== void 0) {\n      newSettings[key] = additionalHotSettingsInProps[key];\n    }\n  }\n\n  return newSettings;\n}\n\n/**\n * Get the VNode element with the provided type attribute from the component slots.\n *\n * @param {Array} componentSlots Array of slots from a component.\n * @param {String} type Type of the child component. Either `hot-renderer` or `hot-editor`.\n * @returns {Object|null} The VNode of the child component (or `null` when nothing's found).\n */\nexport function findVNodeByType(componentSlots: VNode[], type: string): VNode {\n  let componentVNode: VNode = null;\n\n  componentSlots.every((slot, index) => {\n    if (slot.data && slot.data.attrs && slot.data.attrs[type] !== void 0) {\n      componentVNode = slot;\n      return false;\n    }\n\n    return true;\n  });\n\n  return componentVNode;\n}\n\n/**\n * Get all `hot-column` component instances from the provided children array.\n *\n * @param {Array} children Array of children from a component.\n * @returns {Array} Array of `hot-column` instances.\n */\nexport function getHotColumnComponents(children) {\n  return children.filter((child) => child.$options.name === 'HotColumn');\n}\n\n/**\n * Create an instance of the Vue Component based on the provided VNode.\n *\n * @param {Object} vNode VNode element to be turned into a component instance.\n * @param {Object} parent Instance of the component to be marked as a parent of the newly created instance.\n * @param {Object} props Props to be passed to the new instance.\n * @param {Object} data Data to be passed to the new instance.\n */\nexport function createVueComponent(vNode: VNode, parent: Vue, props: object, data: object): EditorComponent {\n  const ownerDocument = parent.$el ? parent.$el.ownerDocument : document;\n  const settings: object = {\n    propsData: props,\n    parent,\n    data\n  };\n\n  if (!bulkComponentContainer) {\n    bulkComponentContainer = ownerDocument.createElement('DIV');\n    bulkComponentContainer.id = 'vueHotComponents';\n\n    ownerDocument.body.appendChild(bulkComponentContainer);\n  }\n\n  const componentContainer = ownerDocument.createElement('DIV');\n  bulkComponentContainer.appendChild(componentContainer);\n\n  return (new (vNode.componentOptions as any).Ctor(settings)).$mount(componentContainer);\n}\n","/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n\n  function LRUMap(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  exports.LRUMap = LRUMap;\n\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n\n\n  LRUMap.prototype._markEntryAsUsed = function(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  };\n\n  LRUMap.prototype.assign = function(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  };\n\n  LRUMap.prototype.get = function(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  };\n\n  LRUMap.prototype.set = function(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  };\n\n  LRUMap.prototype.shift = function() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  };\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n  LRUMap.prototype.has = function(key) {\n    return this._keymap.has(key);\n  };\n});\n","'use strict';\n\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n/* server only */\n, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  } // Vue.extend constructor export interop.\n\n\n  var options = typeof script === 'function' ? script.options : script; // render functions\n\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true; // functional template\n\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  } // scopedId\n\n\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n\n  var hook;\n\n  if (moduleIdentifier) {\n    // server build\n    hook = function hook(context) {\n      // 2.3 injection\n      context = context || // cached call\n      this.$vnode && this.$vnode.ssrContext || // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      } // inject component styles\n\n\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      } // register component module identifier for async chunk inference\n\n\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    }; // used by ssr in case component is cached and beforeCreate\n    // never gets called\n\n\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function () {\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      var originalRender = options.render;\n\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n\n  return script;\n}\n\nmodule.exports = normalizeComponent;\n//# sourceMappingURL=normalize-component.js.map\n","/**\n  * vue-class-component v7.1.0\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport Vue from 'vue';\n\n// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills\n// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.\n// Without this check consumers will encounter hard to track down runtime errors.\nvar reflectionIsSupported = typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;\nfunction copyReflectionMetadata(to, from) {\n    forwardMetadata(to, from);\n    Object.getOwnPropertyNames(from.prototype).forEach(function (key) {\n        forwardMetadata(to.prototype, from.prototype, key);\n    });\n    Object.getOwnPropertyNames(from).forEach(function (key) {\n        forwardMetadata(to, from, key);\n    });\n}\nfunction forwardMetadata(to, from, propertyKey) {\n    var metaKeys = propertyKey\n        ? Reflect.getOwnMetadataKeys(from, propertyKey)\n        : Reflect.getOwnMetadataKeys(from);\n    metaKeys.forEach(function (metaKey) {\n        var metadata = propertyKey\n            ? Reflect.getOwnMetadata(metaKey, from, propertyKey)\n            : Reflect.getOwnMetadata(metaKey, from);\n        if (propertyKey) {\n            Reflect.defineMetadata(metaKey, metadata, to, propertyKey);\n        }\n        else {\n            Reflect.defineMetadata(metaKey, metadata, to);\n        }\n    });\n}\n\nvar fakeArray = { __proto__: [] };\nvar hasProto = fakeArray instanceof Array;\nfunction createDecorator(factory) {\n    return function (target, key, index) {\n        var Ctor = typeof target === 'function'\n            ? target\n            : target.constructor;\n        if (!Ctor.__decorators__) {\n            Ctor.__decorators__ = [];\n        }\n        if (typeof index !== 'number') {\n            index = undefined;\n        }\n        Ctor.__decorators__.push(function (options) { return factory(options, key, index); });\n    };\n}\nfunction mixins() {\n    var Ctors = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Ctors[_i] = arguments[_i];\n    }\n    return Vue.extend({ mixins: Ctors });\n}\nfunction isPrimitive(value) {\n    var type = typeof value;\n    return value == null || (type !== 'object' && type !== 'function');\n}\nfunction warn(message) {\n    if (typeof console !== 'undefined') {\n        console.warn('[vue-class-component] ' + message);\n    }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n    // override _init to prevent to init as Vue instance\n    var originalInit = Component.prototype._init;\n    Component.prototype._init = function () {\n        var _this = this;\n        // proxy to actual vm\n        var keys = Object.getOwnPropertyNames(vm);\n        // 2.2.0 compat (props are no longer exposed as self properties)\n        if (vm.$options.props) {\n            for (var key in vm.$options.props) {\n                if (!vm.hasOwnProperty(key)) {\n                    keys.push(key);\n                }\n            }\n        }\n        keys.forEach(function (key) {\n            if (key.charAt(0) !== '_') {\n                Object.defineProperty(_this, key, {\n                    get: function () { return vm[key]; },\n                    set: function (value) { vm[key] = value; },\n                    configurable: true\n                });\n            }\n        });\n    };\n    // should be acquired class property values\n    var data = new Component();\n    // restore original _init to avoid memory leak (#209)\n    Component.prototype._init = originalInit;\n    // create plain data object\n    var plainData = {};\n    Object.keys(data).forEach(function (key) {\n        if (data[key] !== undefined) {\n            plainData[key] = data[key];\n        }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        if (!(Component.prototype instanceof Vue) && Object.keys(plainData).length > 0) {\n            warn('Component class must inherit Vue or its descendant class ' +\n                'when class property is used.');\n        }\n    }\n    return plainData;\n}\n\nvar $internalHooks = [\n    'data',\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeDestroy',\n    'destroyed',\n    'beforeUpdate',\n    'updated',\n    'activated',\n    'deactivated',\n    'render',\n    'errorCaptured',\n    'serverPrefetch' // 2.6\n];\nfunction componentFactory(Component, options) {\n    if (options === void 0) { options = {}; }\n    options.name = options.name || Component._componentTag || Component.name;\n    // prototype props.\n    var proto = Component.prototype;\n    Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n            return;\n        }\n        // hooks\n        if ($internalHooks.indexOf(key) > -1) {\n            options[key] = proto[key];\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n        if (descriptor.value !== void 0) {\n            // methods\n            if (typeof descriptor.value === 'function') {\n                (options.methods || (options.methods = {}))[key] = descriptor.value;\n            }\n            else {\n                // typescript decorated data\n                (options.mixins || (options.mixins = [])).push({\n                    data: function () {\n                        var _a;\n                        return _a = {}, _a[key] = descriptor.value, _a;\n                    }\n                });\n            }\n        }\n        else if (descriptor.get || descriptor.set) {\n            // computed properties\n            (options.computed || (options.computed = {}))[key] = {\n                get: descriptor.get,\n                set: descriptor.set\n            };\n        }\n    });\n    (options.mixins || (options.mixins = [])).push({\n        data: function () {\n            return collectDataFromConstructor(this, Component);\n        }\n    });\n    // decorate options\n    var decorators = Component.__decorators__;\n    if (decorators) {\n        decorators.forEach(function (fn) { return fn(options); });\n        delete Component.__decorators__;\n    }\n    // find super\n    var superProto = Object.getPrototypeOf(Component.prototype);\n    var Super = superProto instanceof Vue\n        ? superProto.constructor\n        : Vue;\n    var Extended = Super.extend(options);\n    forwardStaticMembers(Extended, Component, Super);\n    if (reflectionIsSupported) {\n        copyReflectionMetadata(Extended, Component);\n    }\n    return Extended;\n}\nvar reservedPropertyNames = [\n    // Unique id\n    'cid',\n    // Super Vue constructor\n    'super',\n    // Component options that will be used by the component\n    'options',\n    'superOptions',\n    'extendOptions',\n    'sealedOptions',\n    // Private assets\n    'component',\n    'directive',\n    'filter'\n];\nvar shouldIgnore = {\n    prototype: true,\n    arguments: true,\n    callee: true,\n    caller: true\n};\nfunction forwardStaticMembers(Extended, Original, Super) {\n    // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable\n    Object.getOwnPropertyNames(Original).forEach(function (key) {\n        // Skip the properties that should not be overwritten\n        if (shouldIgnore[key]) {\n            return;\n        }\n        // Some browsers does not allow reconfigure built-in properties\n        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n        if (extendedDescriptor && !extendedDescriptor.configurable) {\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(Original, key);\n        // If the user agent does not support `__proto__` or its family (IE <= 10),\n        // the sub class properties may be inherited properties from the super class in TypeScript.\n        // We need to exclude such properties to prevent to overwrite\n        // the component options object which stored on the extended constructor (See #192).\n        // If the value is a referenced value (object or function),\n        // we can check equality of them and exclude it if they have the same reference.\n        // If it is a primitive value, it will be forwarded for safety.\n        if (!hasProto) {\n            // Only `cid` is explicitly exluded from property forwarding\n            // because we cannot detect whether it is a inherited property or not\n            // on the no `__proto__` environment even though the property is reserved.\n            if (key === 'cid') {\n                return;\n            }\n            var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n            if (!isPrimitive(descriptor.value) &&\n                superDescriptor &&\n                superDescriptor.value === descriptor.value) {\n                return;\n            }\n        }\n        // Warn if the users manually declare reserved properties\n        if (process.env.NODE_ENV !== 'production' &&\n            reservedPropertyNames.indexOf(key) >= 0) {\n            warn(\"Static property name '\" + key + \"' declared on class '\" + Original.name + \"' \" +\n                'conflicts with reserved property name of Vue internal. ' +\n                'It may cause unexpected behavior of the component. Consider renaming the property.');\n        }\n        Object.defineProperty(Extended, key, descriptor);\n    });\n}\n\nfunction Component(options) {\n    if (typeof options === 'function') {\n        return componentFactory(options);\n    }\n    return function (Component) {\n        return componentFactory(Component, options);\n    };\n}\nComponent.registerHooks = function registerHooks(keys) {\n    $internalHooks.push.apply($internalHooks, keys);\n};\n\nexport default Component;\nexport { createDecorator, mixins };\n"],"names":["unassignedPropSymbol","Symbol","bulkComponentContainer","propFactory","source","registeredHooks","Handsontable","hooks","getRegistered","propSchema","DefaultSettings","prop","i","length","settings","id","type","String","Math","random","toString","substring","wrapperRendererCacheSize","Number","filterPassedProps","props","filteredProps","columnSettingsProp","propName","hasOwnProperty","prepareSettings","assignedProps","hotSettingsInProps","additionalHotSettingsInProps","newSettings","key","findVNodeByType","componentSlots","componentVNode","every","slot","index","data","attrs","createVueComponent","vNode","parent","ownerDocument","$el","document","propsData","createElement","body","appendChild","componentContainer","componentOptions","Ctor","$mount","LRUMap","limit","entries","size","oldest","this","newest","undefined","_keymap","Map","assign","Entry","value","NEWER","OLDER","exports","prototype","_markEntryAsUsed","entry","MAX_VALUE","clear","it","iterator","itv","next","done","e","set","Error","get","shift","has","component","hotInstance","addHook","__internalEdit","children","filter","child","$options","name","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","options","render","staticRenderFns","_compiled","functional","_scopeId","_ssrRegister","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","$root","shadowRoot","originalRender","h","existing","beforeCreate","concat","reflectionIsSupported","Reflect","defineMetadata","getOwnMetadataKeys","forwardMetadata","to","from","propertyKey","forEach","metaKey","metadata","getOwnMetadata","hasProto","__proto__","Array","$internalHooks","componentFactory","Component","_componentTag","proto","Object","getOwnPropertyNames","indexOf","descriptor","getOwnPropertyDescriptor","methods","mixins","push","_a","computed","vm","originalInit","_init","_this","keys","defineProperty","configurable","plainData","collectDataFromConstructor","decorators","__decorators__","fn","superProto","getPrototypeOf","Super","Vue","constructor","Extended","extend","Original","shouldIgnore","extendedDescriptor","superDescriptor","isPrimitive","forwardStaticMembers","copyReflectionMetadata","arguments","callee","caller","registerHooks","apply"],"mappings":"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"}